// ../Include/ParallelBFS/TBaseBFSMixin.hpp

#ifndef PARALLELBFS_TBASEBFSMIXIN_HPP
#define PARALLELBFS_TBASEBFSMIXIN_HPP

#include <concepts>
#include <unordered_map>
#include <vector>
#include <algorithm>

namespace bfs {

template<typename T>
concept CBFSUsable = std::regular<T> and requires(T value) {
		{std::hash<T>{}(value)} -> std::same_as<std::size_t>;
	};

template<CBFSUsable T>
using AGraph = std::unordered_map<T, std::vector<T>>;

template<CBFSUsable T, typename Derived>
class TBaseBFSMixin {
	public:
	template<typename... Args>
	static std::optional<std::vector<T>> Do(const AGraph<T>& graph, const T& start, const T& end, Args&&... args);

	protected:
	TBaseBFSMixin(const AGraph<T>& graph, const T& start, const T& end);

	protected:
	std::optional<std::vector<T>> Execute();

	protected:
	const Derived* self() const;
	Derived* self();

	protected:
	template<typename ValueType>
	std::vector<T> DeterminePath(const std::unordered_map<T, ValueType>& predecessorNodes) const;

	protected:
	const AGraph<T>& m_refGraph;
	const T& m_refStart;
	const T& m_refEnd;
};

template<CBFSUsable T, typename Derived>
template<typename... Args>
std::optional<std::vector<T>> TBaseBFSMixin<T, Derived>::Do(const AGraph<T>& graph, const T& start, const T& end, Args&&... args) {
	auto alg = Derived(graph, start, end, std::forward<Args>(args)...);
	return alg.Execute();
}

template<CBFSUsable T, typename Derived>
TBaseBFSMixin<T, Derived>::TBaseBFSMixin(const AGraph<T>& graph, const T& start, const T& end)
	: m_refGraph{graph}, m_refStart{start}, m_refEnd{end} {}

template<CBFSUsable T, typename Derived>
std::optional<std::vector<T>> TBaseBFSMixin<T, Derived>::Execute() {
	if(m_refStart == m_refEnd) return std::vector{m_refStart, m_refEnd};
	const auto result = self()->PredecessorNodesImpl();
	if(not result) return std::nullopt;
	return DeterminePath(result.value());
}

template<CBFSUsable T, typename Derived>
const Derived* TBaseBFSMixin<T, Derived>::self() const {
	return static_cast<const Derived*>(this);
}

template<CBFSUsable T, typename Derived>
Derived* TBaseBFSMixin<T, Derived>::self() {
	return static_cast<Derived*>(this);
}

template<CBFSUsable T, typename Derived>
template<typename ValueType>
std::vector<T> TBaseBFSMixin<T, Derived>::DeterminePath(
	const std::unordered_map<T, ValueType>& predecessorNodes) const {
	auto path = std::vector<T>{this->m_refEnd};
	auto currentNode = path.front();
	while(currentNode != this->m_refStart) {
		currentNode = predecessorNodes.at(currentNode).second;
		path.push_back(currentNode);
	}
	std::reverse(path.begin(), path.end());
	return path;
}

}

#endif //PARALLELBFS_TBASEBFSMIXIN_HPP


// ../Include/ParallelBFS/TPipes.hpp

#ifndef PARALLELBFS_TPIPES_HPP
#define PARALLELBFS_TPIPES_HPP

#include <concepts>
#include <memory>

namespace bfs {

template<typename T>
concept CPipeUsable = std::default_initializable<T> and std::movable<T>;

template<CPipeUsable T>
class TPipeReader;

template<CPipeUsable T>
class TPipeWriter;

template<CPipeUsable T>
class TPipeChannel;

template<CPipeUsable T>
class TPipeReader {
	friend class TPipeChannel<T>;

	public:
	~TPipeReader()=default;
	TPipeReader(TPipeReader&& other) noexcept;
	TPipeReader& operator=(TPipeReader&& other) noexcept;

	public:
	T Read() const;

	protected:
	TPipeReader() = default;
	TPipeReader(const std::shared_ptr<std::pair<T, std::atomic_flag>>& data);
	TPipeReader(const TPipeReader&) = delete;
	TPipeReader& operator=(const TPipeReader&) = delete;

	protected:
	std::shared_ptr<std::pair<T, std::atomic_flag>> m_pData = nullptr;
};

template<CPipeUsable T>
TPipeReader<T>::TPipeReader(const std::shared_ptr<std::pair<T, std::atomic_flag>>& data)
	: m_pData{data} {
}

template<CPipeUsable T>
TPipeReader<T>::TPipeReader(TPipeReader&& other) noexcept
	: m_pData{std::move(other.m_pData)} {
}

template<CPipeUsable T>
TPipeReader<T>& TPipeReader<T>::operator=(TPipeReader&& other) noexcept {
	this->m_pData = std::move(other.m_pData);
	return *this;
}

template<CPipeUsable T>
T TPipeReader<T>::Read() const {
	m_pData->second.wait(false);
	auto inner = std::move(m_pData->first);
	m_pData->second.clear();
	m_pData->second.notify_one();
	return inner;
}

template<CPipeUsable T>
class TPipeWriter {
	friend class TPipeChannel<T>;

	public:
	~TPipeWriter()=default;
	TPipeWriter(TPipeWriter&& other) noexcept;
	TPipeWriter& operator=(TPipeWriter&& other) noexcept;

	public:
	void Write(T&& value) const;

	protected:
	TPipeWriter() = default;
	TPipeWriter(const std::shared_ptr<std::pair<T, std::atomic_flag>>& data);
	TPipeWriter(const TPipeWriter&) = delete;
	TPipeWriter operator=(const TPipeWriter&) = delete;

	protected:
	std::shared_ptr<std::pair<T, std::atomic_flag>> m_pData = nullptr;
};

template<CPipeUsable T>
TPipeWriter<T>::TPipeWriter(const std::shared_ptr<std::pair<T, std::atomic_flag>>& data)
	: m_pData{data} {
}

template<CPipeUsable T>
TPipeWriter<T>::TPipeWriter(TPipeWriter&& other) noexcept
	: m_pData{std::move(other.m_pData)} {
}

template<CPipeUsable T>
TPipeWriter<T>& TPipeWriter<T>::operator=(TPipeWriter&& other) noexcept {
	this->m_pData = std::move(other.m_pData);
	return *this;
}

template<CPipeUsable T>
void TPipeWriter<T>::Write(T&& value) const {
	m_pData->second.wait(true);
	m_pData->first = std::move(value);
	m_pData->second.test_and_set();
	m_pData->second.notify_one();
}

template<CPipeUsable T>
class TPipeChannel {
	public:
	TPipeChannel();

	public:
	TPipeWriter<T> Writer;
	TPipeReader<T> Reader;
};

template<CPipeUsable T>
TPipeChannel<T>::TPipeChannel() {
	auto data = std::make_shared<std::pair<T, std::atomic_flag>>();
	Writer = TPipeWriter(data);
	Reader = TPipeReader(std::move(data));
}

}

#endif //PARALLELBFS_TPIPES_HPP

// ../Include/ParallelBFS/TSequentialBFS.hpp

#ifndef PARALLELBFS_TSEQUENTIALBFS_HPP
#define PARALLELBFS_TSEQUENTIALBFS_HPP

#include <queue>
#include <unordered_set>
#include <ParallelBFS/TBaseBFSMixin.hpp>

namespace bfs {

template<CBFSUsable T>
class TSequentialBFS : public TBaseBFSMixin<T, TSequentialBFS<T>> {
	friend class TBaseBFSMixin<T, TSequentialBFS<T>>;

	protected:
	TSequentialBFS(const AGraph<T>& graph, const T& start, const T& end);

	protected:
	using AVisitorMap = std::unordered_map<T, std::pair<bool, T>>;
	std::optional<AVisitorMap> PredecessorNodesImpl() const;

	protected:
	AVisitorMap CreateVisitorMap() const;
};

template<CBFSUsable T>
TSequentialBFS<T>::TSequentialBFS(const AGraph<T>& graph, const T& start, const T& end)
	: TBaseBFSMixin<T, TSequentialBFS>(graph, start, end) {}

template<CBFSUsable T>
std::optional<typename TSequentialBFS<T>::AVisitorMap>
    TSequentialBFS<T>::PredecessorNodesImpl() const {
	auto queue = std::queue<T>({this->m_refStart});
	auto visitorMap = CreateVisitorMap();
	auto isFoundEndNode = false;
	while(not queue.empty() and not isFoundEndNode) {
		const auto currentNode = std::move(queue.front());
		queue.pop();
		for(const auto& neighbour : this->m_refGraph.at(currentNode)) {
			const auto neighbourIt = visitorMap.find(neighbour);
			if(not neighbourIt->second.first) {
				neighbourIt->second.first = true;
				neighbourIt->second.second = currentNode;
				if(neighbour == this->m_refEnd) {
					isFoundEndNode = true;
					break;
				}
				queue.push(neighbour);
			}
		}
	}
	if(not isFoundEndNode) return std::nullopt;
	return visitorMap;
}

template<CBFSUsable T>
TSequentialBFS<T>::AVisitorMap TSequentialBFS<T>::CreateVisitorMap() const {
	auto visitorMap = std::unordered_map<T, std::pair<bool, T>>();
	visitorMap.reserve(this->m_refGraph.size());
	for(const auto& [key, _] : this->m_refGraph) {
		visitorMap.insert_or_assign(key, std::make_pair(false, T()));
	}
	return visitorMap;
}

}

#endif //PARALLELBFS_TSEQUENTIALBFS_HPP


// ../Include/ParallelBFS/THelpers.hpp

#ifndef PARALLELBFS_THELPERS_HPP
#define PARALLELBFS_THELPERS_HPP

#include <variant>
#include <string_view>
#include <source_location>

namespace bfs {

template<typename VariantType, typename T, std::size_t index = 0>
constexpr std::size_t VariantIndex() {
	static_assert(std::variant_size_v<VariantType> > index, "Type not found in variant");
	if constexpr (index == std::variant_size_v<VariantType>) {
		return index;
	} else if constexpr (std::is_same_v<std::variant_alternative_t<index, VariantType>, T>) {
		return index;
	} else {
		return VariantIndex<VariantType, T, index + 1>();
	}
}

namespace lr {
	enum class NLevel {
		Info,
		Warn,
		Error
	};

	void Log(
		const std::string_view message,
		const NLevel level,
		std::source_location location = std::source_location::current()
	);

	void LogInfo(
		const std::string_view message,
		std::source_location location = std::source_location::current()
	);

	void LogWarn(
		const std::string_view message,
		std::source_location location = std::source_location::current()
	);

	void LogError(
		const std::string_view message,
		std::source_location location = std::source_location::current()
	);

	[[noreturn]] void Error(
		const std::string_view message,
		std::source_location location = std::source_location::current()
	);

	[[noreturn]] void UnsopportedCaseError(
		std::source_location location = std::source_location::current()
	);

}

}

#endif //PARALLELBFS_THELPERS_HPP


// ../Include/ParallelBFS/TCommunicationBFS.hpp

#ifndef PARALLELBFS_TCOMMUNICATIONBFS_HPP
#define PARALLELBFS_TCOMMUNICATIONBFS_HPP

#include <ParallelBFS/THelpers.hpp>
#include <ParallelBFS/TPipes.hpp>
#include <ParallelBFS/TDeque.hpp>
#include <ParallelBFS/TBaseBFSMixin.hpp>

#include <thread>

namespace bfs {

template<CBFSUsable T>
class TCommunicationBFS : public TBaseBFSMixin<T, TCommunicationBFS<T>> {
	protected:
	friend class TBaseBFSMixin<T, TCommunicationBFS<T>>;

	protected:
	TCommunicationBFS(const AGraph<T>& graph, const T& start, const T& end, const unsigned threadsNum);

	protected:
	using AVisitorMap = std::unordered_map<T, std::pair<std::atomic_flag, T>>;

	protected:
	AVisitorMap CreateVisitorMap() const;

	protected:
	const unsigned m_uThreadsNum = 0;

	protected:
	std::optional<AVisitorMap> PredecessorNodesImpl() const;

	protected:
	// Messages
	struct SContinueIteration {};
	struct SEndNodeFound {};
	struct SAllNodesEnqueued {};
	struct SQueueView {
		const TDeque<T>* Deque;
		size_t Begin;
		size_t End;
	};
	struct SFrontier {
		std::vector<T> Data;
	};

	using AParentMessage = std::variant<
		SEndNodeFound,
		SAllNodesEnqueued,
		SQueueView>;

	using AChildrenMessage = std::variant<
		SEndNodeFound,
		SFrontier>;

	using ACommunicationResult = std::variant<
		SAllNodesEnqueued,
		SEndNodeFound
	>;

	using AIterationResult = std::variant<
		SEndNodeFound,
		SContinueIteration
	>;

	protected:
	ACommunicationResult Communicate(
		TDeque<T>& deque,
		size_t& totalEnqueuedNum,
		AVisitorMap& visitorMap,
		std::vector<TPipeWriter<AParentMessage>>& senders,
		std::vector<TPipeReader<AChildrenMessage>>& listeners
	) const;

	AChildrenMessage DoPartialWork(
		const SQueueView& queueView,
		AVisitorMap& visitorMap) const;

	void ChildThreadWork(
		const TPipeWriter<AChildrenMessage>& childSender,
		const TPipeReader<AParentMessage>& parentListener,
		AVisitorMap& visitorMap
	) const;

	AChildrenMessage IterateWork(
		const TDeque<T>& deque,
		const std::vector<TPipeWriter<AParentMessage>>& senders,
		AVisitorMap& visitorMap
	) const;

	auto ProcessIterationResult(
		TDeque<T>& deque,
		AChildrenMessage&& partialResult,
		const std::vector<TPipeWriter<AParentMessage>>& senders,
		size_t& totalEnqueued
	) const -> AIterationResult;

	template<typename MessageType>
	MessageType SendMessageToAll(const std::vector<TPipeWriter<AParentMessage>>& senders) const;
};

template<CBFSUsable T>
TCommunicationBFS<T>::TCommunicationBFS(
	const AGraph<T>& graph,
	const T& start,
	const T& end,
	const unsigned threadsNum
) :	TBaseBFSMixin<T, TCommunicationBFS>(graph, start, end),
	m_uThreadsNum{threadsNum} {}

template<CBFSUsable T>
std::unordered_map<T, std::pair<std::atomic_flag, T>>
	TCommunicationBFS<T>::CreateVisitorMap() const {
	auto visitorMap = std::unordered_map<T, std::pair<std::atomic_flag, T>>();
	visitorMap.reserve(this->m_refGraph.size());
	for(const auto& [key, _] : this->m_refGraph) {
		auto [it, isEnqueued] = visitorMap.emplace(std::piecewise_construct,
			std::forward_as_tuple(key), std::forward_as_tuple());
		it->second.first.clear();
	}
	return visitorMap;
}

template<CBFSUsable T>
std::optional<typename TCommunicationBFS<T>::AVisitorMap>
    TCommunicationBFS<T>::PredecessorNodesImpl() const {

	auto deque = TDeque<T>();
	deque.Push({this->m_refStart});
	size_t totalEnqueuedNum = 0;
	auto visitorMap = this->CreateVisitorMap();
	auto senders = std::vector<TPipeWriter<AParentMessage>>();
	auto listeners = std::vector<TPipeReader<AChildrenMessage>>();

	const auto result = Communicate(deque, totalEnqueuedNum,
		visitorMap, senders, listeners);

	switch(result.index()) {
		case VariantIndex<ACommunicationResult, SAllNodesEnqueued>(): {
			return std::nullopt;
		}
		case VariantIndex<ACommunicationResult, SEndNodeFound>(): {
			return visitorMap;
		}
		default: {
			lr::UnsopportedCaseError();
		}
	}
}

template<CBFSUsable T>
auto TCommunicationBFS<T>::Communicate(
		TDeque<T>& deque,
		size_t& totalEnqueuedNum,
		AVisitorMap& visitorMap,
		std::vector<TPipeWriter<AParentMessage>>& senders,
		std::vector<TPipeReader<AChildrenMessage>>& listeners
	) const -> ACommunicationResult {

	auto threads = std::vector<std::jthread>();
	for(auto i = 0u; i < this->m_uThreadsNum - 1; ++i) {
		auto [parentSender, parentListener] = TPipeChannel<AParentMessage>();
		auto [childrenSender, childrenListener] = TPipeChannel<AChildrenMessage>();
		senders.push_back(std::move(parentSender));
		listeners.push_back(std::move(childrenListener));
		threads.emplace_back([this,
			sender=std::move(childrenSender),
			listener=std::move(parentListener), &visitorMap] {
			ChildThreadWork(sender, listener, visitorMap);
		});
	}

	while(true) {
		auto newDeque = TDeque<T>();
		{
			auto partRes = IterateWork(deque, senders, visitorMap);
			const auto iterResult = ProcessIterationResult(newDeque,
				std::move(partRes), senders, totalEnqueuedNum);
			if(std::holds_alternative<SEndNodeFound>(iterResult)) {
				return SEndNodeFound{};
			}
		}
		for(auto& l : listeners) {
			auto partRes = l.Read();
			auto iterResult = ProcessIterationResult(newDeque,
				std::move(partRes), senders, totalEnqueuedNum);
			if(std::holds_alternative<SEndNodeFound>(iterResult)) {
				return SEndNodeFound{};
			}
		}
		deque = std::move(newDeque);
		if(totalEnqueuedNum >= this->m_refGraph.size()) {
			return SendMessageToAll<SAllNodesEnqueued>(senders);
		}
	}

	return SAllNodesEnqueued{};
}

template<CBFSUsable T>
auto TCommunicationBFS<T>::ProcessIterationResult(
	TDeque<T>& deque,
	AChildrenMessage&& partialResult,
	const std::vector<TPipeWriter<AParentMessage>>& senders,
	size_t& totalEnqueued
) const -> AIterationResult {
	switch(partialResult.index()) {
		case VariantIndex<AChildrenMessage, SEndNodeFound>(): {
			return SendMessageToAll<SEndNodeFound>(senders);
		}
		case VariantIndex<AChildrenMessage, SFrontier>(): {
			auto& frontier = std::get<SFrontier>(partialResult);
			totalEnqueued += frontier.Data.size();
			if(not frontier.Data.empty()) {
				deque.Push(std::move(frontier.Data));
			}
			return SContinueIteration{};
		}
		default: {
			lr::UnsopportedCaseError();
		}
	}
}

template<CBFSUsable T>
auto TCommunicationBFS<T>::DoPartialWork(
	const SQueueView& queueView,
	AVisitorMap& visitorMap
) const -> AChildrenMessage {

	auto frontier = SFrontier();
	auto isEndNodeFound = false;
	queueView.Deque->Loop(queueView.Begin, queueView.End,
		[this, &frontier, &isEndNodeFound, &visitorMap](const T& node) {
		for(const auto& neighbour : this->m_refGraph.at(node)) {
			const auto neighbourIt = visitorMap.find(neighbour);
			if(neighbourIt->second.first.test_and_set())
				continue;
			neighbourIt->second.second = node;
			if(neighbour == this->m_refEnd) {
				isEndNodeFound = true;
				return;
			}
			frontier.Data.push_back(neighbour);
		}
	});

	if(isEndNodeFound) return SEndNodeFound{};

	return frontier;
}

template<CBFSUsable T>
void TCommunicationBFS<T>::ChildThreadWork(
	const TPipeWriter<AChildrenMessage>& childSender,
	const TPipeReader<AParentMessage>& parentListener,
	AVisitorMap& visitorMap
) const {
	while(true) {
		const auto parentMessage = parentListener.Read();
		switch(parentMessage.index()) {
			case VariantIndex<AParentMessage, SEndNodeFound>():
			case VariantIndex<AParentMessage, SAllNodesEnqueued>(): {
				return;
			}
			case VariantIndex<AParentMessage, SQueueView>(): {
				const auto& queueView = std::get<SQueueView>(parentMessage);
				childSender.Write(DoPartialWork(queueView, visitorMap));
				break;
			}
			default: {
				lr::UnsopportedCaseError();
			}
		}
	}
}

template<CBFSUsable T>
auto TCommunicationBFS<T>::IterateWork(
	const TDeque<T>& deque,
	const std::vector<TPipeWriter<AParentMessage>>& senders,
	AVisitorMap& visitorMap
) const -> AChildrenMessage {
	const auto dequeSize = deque.Size();
	const auto step = dequeSize / this->m_uThreadsNum;
	const auto remainder = dequeSize % this->m_uThreadsNum;
	for(size_t t = 0, index = 0; t < this->m_uThreadsNum; ++t) {
		auto queueView = SQueueView{};
		queueView.Deque = &deque;
		if(index >= dequeSize) {
			queueView.Begin = dequeSize;
			queueView.End = dequeSize;
		} else {
			const auto localStep = t < remainder ? step + 1 : step;
			queueView.Begin = index;
			queueView.End = index + localStep;
			index += localStep;
		}
		if(t == this->m_uThreadsNum - 1) {
			return DoPartialWork(queueView, visitorMap);
		} else {
			senders[t].Write(queueView);
		}
	}
	return SEndNodeFound{};
}

template<CBFSUsable T>
template<typename MessageType>
MessageType TCommunicationBFS<T>::SendMessageToAll(
	const std::vector<TPipeWriter<AParentMessage>>& senders
) const {
	auto message = MessageType{};
	for(auto& s : senders) {
		s.Write(message);
	}
	return MessageType{};
}

}

#endif //PARALLELBFS_TCOMMUNICATIONBFS_HPP

// ../Include/ParallelBFS/TDeque.hpp

#ifndef PARALLELBFS_TDEQUE_HPP
#define PARALLELBFS_TDEQUE_HPP

#include <vector>
#include <optional>

namespace bfs {

template<typename T>
class TDeque {
	public:
	TDeque()=default;

	public:
	void Push(std::vector<T>&& value);
	std::size_t Size() const noexcept;
	void Loop(const size_t begin, const size_t end,
		const std::function<void(const T& el)>& func) const;

	protected:
	std::vector<std::vector<T>> m_vData;
};

template<typename T>
void TDeque<T>::Push(std::vector<T>&& value) {
	m_vData.push_back(std::move(value));
}

template<typename T>
std::size_t TDeque<T>::Size() const noexcept {
	auto size = size_t(0);
	for(const auto& el : m_vData) {
		size += el.size();
	}
	return size;
}

template<typename T>
void TDeque<T>::Loop(const size_t begin, const size_t end,
	const std::function<void(const T&)>& func) const {
	if(begin == end) return;
	auto vectorIt = m_vData.begin();
	auto elIt = m_vData.begin()->begin();

	auto delay = begin;
	auto dist = vectorIt->end() - elIt;
	while(delay >= dist) {
		delay -= dist;
		++vectorIt;
		elIt = vectorIt->begin();
		dist = vectorIt->end() - elIt;
	}

	elIt += delay;

	for(auto i = begin; i < end; ++i, ++elIt) {
		if(elIt == vectorIt->end()) {
			++vectorIt;
			elIt = vectorIt->begin();
		}
		func(*elIt);
	}
}

}

#endif //PARALLELBFS_TDEQUE_HPP


// ../Tests/Deque.cpp

#include <gtest/gtest.h>
#include <ParallelBFS/TDeque.hpp>

class TDequeTest
	: public testing::TestWithParam<std::array<int, 2>> {
	protected:
	static void SetUpTestSuite();
	static bfs::TDeque<int> s_vDeque;
};

void TDequeTest::SetUpTestSuite() {
	s_vDeque.Push({0, 1, 2, 3, 4});
	s_vDeque.Push({5, 6, 7, 8, 9});
	s_vDeque.Push({10, 11, 12, 13, 14});
}

bfs::TDeque<int> TDequeTest::s_vDeque = bfs::TDeque<int>();

INSTANTIATE_TEST_SUITE_P(Loop, TDequeTest,
	testing::Values(std::array{0, 15}, std::array{3, 12}));

TEST_P(TDequeTest, Loop) {
	auto [beginIt, endIt] = GetParam();
	s_vDeque.Loop(beginIt, endIt, [&beginIt](const auto& el) {
		EXPECT_EQ(el, beginIt);
		++beginIt;
	});
	EXPECT_EQ(beginIt, endIt);
}

// ../Tests/Pipes.cpp

#include <thread>
#include <gtest/gtest.h>
#include <ParallelBFS/TPipes.hpp>

TEST(Pipes, Transfer) {
	auto [w, r] = bfs::TPipeChannel<int>();

	auto sender = std::jthread([ww=std::move(w)]() {
		using namespace std::chrono_literals;
		std::this_thread::sleep_for(4s);
		ww.Write(10);
	});

	auto listener = std::jthread([rr=std::move(r)]() {
		EXPECT_EQ(rr.Read(), 10);
	});
}

// ../Tests/Benchmark.cpp

#include <format>
#include <ranges>
#include <fstream>
#include <filesystem>
#include <gtest/gtest.h>
#include <ParallelBFS/TSequentialBFS.hpp>
#include <ParallelBFS/TCommunicationBFS.hpp>

class TTestBFSFixture : public ::testing::Test {
	protected:
	static std::unordered_map<unsigned, std::vector<unsigned>> Create2DGrid(const unsigned int size);
	static bool IsPathValid(const std::vector<unsigned int>& path, const bfs::AGraph<unsigned int>& graph);
	static unsigned GetLastIndex(const unsigned size);
	static void WriteToReport(const std::string& str);
};

std::unordered_map<unsigned, std::vector<unsigned>>
TTestBFSFixture::Create2DGrid(const unsigned int size) {
	auto grid = std::unordered_map<unsigned, std::vector<unsigned>>();
	const auto totalSize = size * size;
	grid.reserve(totalSize);
	for(auto index = 0u; index < totalSize; ++index) {
		const auto x = static_cast<int>(index % size);
		const auto y = static_cast<int>(index / size);
		const auto utmost = static_cast<int>(size) - 1;
		auto neighbourIndexes = std::vector<unsigned>();
		for(auto deltaY = -1; deltaY <= 1; ++deltaY) {
			const auto newY = y + deltaY;
			if(newY < 0 or newY > utmost) continue;
			const auto base = static_cast<unsigned>(newY) * size;
			for(auto deltaX = -1; deltaX <= 1; ++deltaX) {
				if(deltaY == 0 && deltaX == 0) continue;
				const auto newX = x + deltaX;
				if(newX < 0 or newX > utmost) continue;
				const auto offset = static_cast<unsigned>(newX);
				neighbourIndexes.push_back(base + offset);
			}
		}
		grid.insert_or_assign(index, neighbourIndexes);
	}
	return grid;
}

bool TTestBFSFixture::IsPathValid(
	const std::vector<unsigned int>& path,
	const bfs::AGraph<unsigned int>& graph) {
	for(const auto& [start, end] : path | std::views::pairwise) {
		const auto it = graph.find(start);
		if(it == graph.end()) {
			return false;
		}
		const auto isContain = std::ranges::contains(it->second, end);
		if(not isContain) {
			return false;
		}
	}
	return true;
}

unsigned TTestBFSFixture::GetLastIndex(const unsigned size) {
	return (size - 1) * size + size - 1;
}

void TTestBFSFixture::WriteToReport(const std::string& str) {
	std::ofstream("Benchmark.txt", std::ios::app) << str << std::endl;
}

TEST_F(TTestBFSFixture, Test) {
	constexpr auto totalRepeats = 1u;
	const auto sizes = std::vector<unsigned>{2500, 2625, 2750, 2875, 3000, 3125, 3250, 3500, 3635, 3750, 3875, 4000};
	// const auto sizes = std::vector<unsigned>{1000, 1200, 1300, 1400};
	const auto threadsNums = std::vector<unsigned>{2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};
	for(const auto size : sizes) {
		const auto grid = Create2DGrid(size);
		const auto lastIndex = GetLastIndex(size);
		for(auto i = 0u; i < totalRepeats; ++i) {
			const auto [sequentialMillis, singleRes] = [&grid, &lastIndex, &size]() {
				const auto start = std::chrono::system_clock::now();
				auto result = bfs::TSequentialBFS<unsigned>::Do(grid, 0, lastIndex);
				const auto delay = std::chrono::system_clock::now() - start;
				const auto millis = std::chrono::duration_cast<std::chrono::milliseconds>(delay).count();
				EXPECT_TRUE(IsPathValid(result.value(), grid));
				WriteToReport(std::format("{{ \"name\": {}, \"size\": {}, \"milliseconds\": {} }}", "Sequential", size, millis));
				return std::make_tuple(static_cast<double>(millis), std::move(result.value()));
			}();
			for(const auto threadsNum : threadsNums) {
				const auto start = std::chrono::system_clock::now();
				const auto result = bfs::TCommunicationBFS<unsigned>::Do(grid, 0, lastIndex, threadsNum);
				const auto delay = std::chrono::system_clock::now() - start;
				const auto millis = static_cast<double>(std::chrono::duration_cast<std::chrono::milliseconds>(delay).count());
				EXPECT_TRUE(IsPathValid(result.value(), grid));
				EXPECT_EQ(result.value(), singleRes);
				WriteToReport(std::format("{{ \"name\": \"{}\", \"size\": {}, \"threadsNum\": {}, \"milliseconds\": {}, \"acceleration\": {} }}",
					"Communication", size, threadsNum, millis, sequentialMillis / millis));
			}
		}
	}
}


